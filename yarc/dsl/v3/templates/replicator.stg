group replicator;

scenario(name, settings, stage, writers) ::=
<<
# Scenario <name>
import omni.usd
import omni.replicator.core as rep

from pxr import Gf
from omni.demo.data_generator import get_files, save_meshes, get_prims
<settings>

with rep.new_layer():
  <stage>
  
  <writers>
  
>>

settings(setting_list) ::= 
<<
# settings
<setting_list; separator="\n">
settings = {
  
}
>>

setting(setting, value) ::=
<<
rep.settings.carb_settings(setting="<setting>", value=<value>)
>>

writers(stmts) ::=
<<
# writers
<stmts; separator="\n">
>>

writer(writer_id, writer_params, rps) ::=
<<
writer = rep.WriterRegistry.get("<writer_id>")
writer.initialize(
  <writer_params; separator=",\n">
)
writer.attach([<rps; separator=", ">])

>>

writer_param(param, value) ::=
<<
<param>=<value>
>>

stage(stmts) ::=
<<
<stmts; separator="\n">
>>

open_stmt(path) ::=
<<
omni.usd.get_context().open_stage(<path>)

>>

edit_timeline(params, values) ::=
<<
<params,values: { p,v | rep.modify.<p>(value=<v>)}; separator="\n">

>>

fetch_expr(ext, path, filter, limit, recursive) ::=
<<
get_files(path=<path>, exts=<ext><if(recursive)>, recursive=True<endif><if(filter)>, path_filter=<filter><endif><if(limit)>, max_files=<limit><endif>)
>>

expr_stmt(assignable, op, value) ::=
<<
<assignable> <op> <value>
>>

test(expr, cond, else_expr) ::=
<<
<expr><if(cond)> if <cond> else <else_expr><endif>
>>

or_test(exprs) ::=
<<
<exprs; separator=" or ">
>>

and_test(exprs) ::=
<<
<exprs; separator=" and ">
>>

not_test(expr) ::=
<<
not <expr>
>>

comparison(exprs, op) ::= 
<<
<exprs; separator=" "+op.text+" ">
>>

expr(exprs) ::=
<<
<exprs; separator=" | ">
>>

xor_expr(exprs) ::=
<<
<exprs; separator=" ^ ">
>>

and_expr(exprs) ::=
<<
<exprs; separator=" & ">
>>

shift_expr(exprs, op) ::=
<<
<exprs; separator=" "+op.text+" ">
>>

arith_expr(terms, op) ::=
<<
<terms; separator=" "+op.text+" ">
>>

term(factors, op) ::=
<<
<factors; separator=" "+op.text+" ">
>>

prefix_factor(factor, prefix) ::=
<<
<if(prefix)><prefix.text><endif><factor>
>>

power(atom, factor) ::=
<<
<atom><if(factor)> ** <factor><endif>
>>

atom_expr(atom, trailers) ::=
<<
<atom><trailers; separator="">
>>

parenthesized_expr(expr) ::= 
<<
(<expr>)
>>

list(list_comp) ::=
<<
[<if(list_comp)><list_comp><endif>]
>>

vector(values) ::=
<<
Gf.Vec3d(<values>)
>>

dict(dict_comp) ::=
<<
{<if(dict_comp)><dict_comp><endif>}
>>

len(value) ::=
<<
len(<value>)
>>

setting_id(id) ::=
<<
settings["<id>"]
>>

distribution(name, arglist) ::=
<<
rep.distribution.<name>(<arglist>)
>>

null() ::= "None"
true() ::= "True"
false() ::= "False"

list_comp(expr, for) ::=
<<
<expr> <for>
>>

test_list(exprs) ::= 
<<
<exprs; separator=", ">
>>

range(from, to, step) ::=
<<
list(*range(<from>, <to><if(step)>, <step><endif>))
>>

vector_comp(x, y, z) ::=
<<
<x>, <y>, <z>
>>

index(index) ::=
<<
[<index>]
>>

dot_attr(attr) ::=
<<
["<attr>"]
>>

arg_list(args) ::= 
<<
<args; separator=", ">
>>

arg(kw_or_arg, arg) ::=
<<
<kw_or_arg> <if(arg)>= <arg><endif>
>>

subscript_list(subs) ::= 
<<
<subs; separator=", ">
>>

subscript(from, colon, to, step) ::=
<<
<if(from)><from><endif><if(colon)>:<endif><if(to)><to><endif><step>
>>

subscript_step(step) ::=
<<
:<if(step)><step><endif>
>>

dict_comp(key, value, for) ::=
<<
<key>: <value> <for>
>>

key_value_list(keys, values) ::=
<<
<keys,values:{ k,v | k: v}; separator=", ">
>>

comp_for(exprs, seq, comp_iter) ::=
<<
for <exprs> in <seq><if(comp_iter)> <comp_iter><endif>
>>

comp_if(cond, comp_iter) ::= 
<<
if <cond><if(comp_iter)> <comp_iter><endif>
>>
